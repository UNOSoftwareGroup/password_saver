<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Django Project: _pytest.pathlib Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Django Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('namespace__pytest_1_1pathlib.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">_pytest.pathlib Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class__pytest_1_1pathlib_1_1_could_not_resolve_path_error.html">CouldNotResolvePathError</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class__pytest_1_1pathlib_1_1_import_mode.html">ImportMode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class__pytest_1_1pathlib_1_1_import_path_mismatch_error.html">ImportPathMismatchError</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a49fb18e734de79bf93247d67a201673b" id="r_a49fb18e734de79bf93247d67a201673b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a49fb18e734de79bf93247d67a201673b">_ignore_error</a> (Exception exception)</td></tr>
<tr class="separator:a49fb18e734de79bf93247d67a201673b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71cc9f2b91e8d7c2f31e80cc596fc1ad" id="r_a71cc9f2b91e8d7c2f31e80cc596fc1ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a0eaa54319ebbb1846a29cd4ad31da4d4">_AnyPurePath</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a71cc9f2b91e8d7c2f31e80cc596fc1ad">get_lock_path</a> (<a class="el" href="#a0eaa54319ebbb1846a29cd4ad31da4d4">_AnyPurePath</a> path)</td></tr>
<tr class="separator:a71cc9f2b91e8d7c2f31e80cc596fc1ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a230d9829caff4723397aee03ddadc7ae" id="r_a230d9829caff4723397aee03ddadc7ae"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a230d9829caff4723397aee03ddadc7ae">on_rm_rf_error</a> (Callable[..., Any]|None func, str path, BaseException|tuple[type[BaseException], BaseException, types.TracebackType|None] excinfo, *, Path start_path)</td></tr>
<tr class="separator:a230d9829caff4723397aee03ddadc7ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b8b0325e6efac0c038f9a724ab8a2bf" id="r_a6b8b0325e6efac0c038f9a724ab8a2bf"><td class="memItemLeft" align="right" valign="top">Path&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6b8b0325e6efac0c038f9a724ab8a2bf">ensure_extended_length_path</a> (Path path)</td></tr>
<tr class="separator:a6b8b0325e6efac0c038f9a724ab8a2bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae544da450e5c7c6870a70be7cabc75d8" id="r_ae544da450e5c7c6870a70be7cabc75d8"><td class="memItemLeft" align="right" valign="top">str&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae544da450e5c7c6870a70be7cabc75d8">get_extended_length_path_str</a> (str path)</td></tr>
<tr class="separator:ae544da450e5c7c6870a70be7cabc75d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1f0c08537ab64dd461cfb6674625b38" id="r_ae1f0c08537ab64dd461cfb6674625b38"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae1f0c08537ab64dd461cfb6674625b38">rm_rf</a> (Path path)</td></tr>
<tr class="separator:ae1f0c08537ab64dd461cfb6674625b38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1843653a064d8dee4dcf9a5cc00679c" id="r_ab1843653a064d8dee4dcf9a5cc00679c"><td class="memItemLeft" align="right" valign="top">Iterator[os.DirEntry[str]]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab1843653a064d8dee4dcf9a5cc00679c">find_prefixed</a> (Path root, str prefix)</td></tr>
<tr class="separator:ab1843653a064d8dee4dcf9a5cc00679c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0addba70a654b247e36cb4401bc7dc12" id="r_a0addba70a654b247e36cb4401bc7dc12"><td class="memItemLeft" align="right" valign="top">Iterator[str]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0addba70a654b247e36cb4401bc7dc12">extract_suffixes</a> (Iterable[os.DirEntry[str]] iter, str prefix)</td></tr>
<tr class="separator:a0addba70a654b247e36cb4401bc7dc12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5a66215e40cad20f751eddc3c6e8721" id="r_ae5a66215e40cad20f751eddc3c6e8721"><td class="memItemLeft" align="right" valign="top">Iterator[str]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae5a66215e40cad20f751eddc3c6e8721">find_suffixes</a> (Path root, str prefix)</td></tr>
<tr class="separator:ae5a66215e40cad20f751eddc3c6e8721"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef6232b74550a186a8206597eefc3737" id="r_aef6232b74550a186a8206597eefc3737"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aef6232b74550a186a8206597eefc3737">parse_num</a> (str maybe_num)</td></tr>
<tr class="separator:aef6232b74550a186a8206597eefc3737"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d36d17900127934577a8859d235bcfd" id="r_a2d36d17900127934577a8859d235bcfd"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2d36d17900127934577a8859d235bcfd">_force_symlink</a> (Path root, str|PurePath target, str|Path link_to)</td></tr>
<tr class="separator:a2d36d17900127934577a8859d235bcfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ca62f92c9e61a349836eadf38245d85" id="r_a6ca62f92c9e61a349836eadf38245d85"><td class="memItemLeft" align="right" valign="top">Path&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6ca62f92c9e61a349836eadf38245d85">make_numbered_dir</a> (Path root, str prefix, int mode=0o700)</td></tr>
<tr class="separator:a6ca62f92c9e61a349836eadf38245d85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fae1b99c0fbb9d314aceb95e668a401" id="r_a2fae1b99c0fbb9d314aceb95e668a401"><td class="memItemLeft" align="right" valign="top">Path&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2fae1b99c0fbb9d314aceb95e668a401">create_cleanup_lock</a> (Path p)</td></tr>
<tr class="separator:a2fae1b99c0fbb9d314aceb95e668a401"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18e8d477b40f4178236b4e1a1465e550" id="r_a18e8d477b40f4178236b4e1a1465e550"><td class="memItemLeft" align="right" valign="top">Any&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a18e8d477b40f4178236b4e1a1465e550">register_cleanup_lock_removal</a> (Path lock_path, Any register=atexit.register)</td></tr>
<tr class="separator:a18e8d477b40f4178236b4e1a1465e550"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13e58fca02f174fa9bd72475840e51cc" id="r_a13e58fca02f174fa9bd72475840e51cc"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a13e58fca02f174fa9bd72475840e51cc">maybe_delete_a_numbered_dir</a> (Path path)</td></tr>
<tr class="separator:a13e58fca02f174fa9bd72475840e51cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c3f573b2bcd340dc200f85899715bfa" id="r_a1c3f573b2bcd340dc200f85899715bfa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1c3f573b2bcd340dc200f85899715bfa">ensure_deletable</a> (Path path, float consider_lock_dead_if_created_before)</td></tr>
<tr class="separator:a1c3f573b2bcd340dc200f85899715bfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94a716332cee4b0ffe6806ccfd56c390" id="r_a94a716332cee4b0ffe6806ccfd56c390"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a94a716332cee4b0ffe6806ccfd56c390">try_cleanup</a> (Path path, float consider_lock_dead_if_created_before)</td></tr>
<tr class="separator:a94a716332cee4b0ffe6806ccfd56c390"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae357103ea4a06ecb2d8bd3b18af4ea53" id="r_ae357103ea4a06ecb2d8bd3b18af4ea53"><td class="memItemLeft" align="right" valign="top">Iterator[Path]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae357103ea4a06ecb2d8bd3b18af4ea53">cleanup_candidates</a> (Path root, str prefix, int keep)</td></tr>
<tr class="separator:ae357103ea4a06ecb2d8bd3b18af4ea53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a029804adc1a9bf460f063bad46dade6a" id="r_a029804adc1a9bf460f063bad46dade6a"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a029804adc1a9bf460f063bad46dade6a">cleanup_dead_symlinks</a> (Path root)</td></tr>
<tr class="separator:a029804adc1a9bf460f063bad46dade6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d1e52490b7f908dbc8b6041d0bba697" id="r_a9d1e52490b7f908dbc8b6041d0bba697"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9d1e52490b7f908dbc8b6041d0bba697">cleanup_numbered_dir</a> (Path root, str prefix, int keep, float consider_lock_dead_if_created_before)</td></tr>
<tr class="separator:a9d1e52490b7f908dbc8b6041d0bba697"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31cda2f173f0946adac7122c00608b88" id="r_a31cda2f173f0946adac7122c00608b88"><td class="memItemLeft" align="right" valign="top">Path&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a31cda2f173f0946adac7122c00608b88">make_numbered_dir_with_cleanup</a> (Path root, str prefix, int keep, float lock_timeout, int mode)</td></tr>
<tr class="separator:a31cda2f173f0946adac7122c00608b88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16d692771185c792d8b0f888953061d9" id="r_a16d692771185c792d8b0f888953061d9"><td class="memItemLeft" align="right" valign="top">Path&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a16d692771185c792d8b0f888953061d9">resolve_from_str</a> (str input, Path rootpath)</td></tr>
<tr class="separator:a16d692771185c792d8b0f888953061d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b1004d7bebd54d347c235848846e2e8" id="r_a6b1004d7bebd54d347c235848846e2e8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6b1004d7bebd54d347c235848846e2e8">fnmatch_ex</a> (str pattern, str|os.PathLike[str] path)</td></tr>
<tr class="separator:a6b1004d7bebd54d347c235848846e2e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb98e10060724ec1d7bcffc434ee55d8" id="r_afb98e10060724ec1d7bcffc434ee55d8"><td class="memItemLeft" align="right" valign="top">set[str]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afb98e10060724ec1d7bcffc434ee55d8">parts</a> (str s)</td></tr>
<tr class="separator:afb98e10060724ec1d7bcffc434ee55d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96f2306195bc2afab763d5bd8c20ae9d" id="r_a96f2306195bc2afab763d5bd8c20ae9d"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a96f2306195bc2afab763d5bd8c20ae9d">symlink_or_skip</a> (os.PathLike[str]|str src, os.PathLike[str]|str dst, **Any kwargs)</td></tr>
<tr class="separator:a96f2306195bc2afab763d5bd8c20ae9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbc8e461599c3d27cc24516ee5565e13" id="r_adbc8e461599c3d27cc24516ee5565e13"><td class="memItemLeft" align="right" valign="top">ModuleType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adbc8e461599c3d27cc24516ee5565e13">import_path</a> (str|os.PathLike[str] path, *, str|<a class="el" href="class__pytest_1_1pathlib_1_1_import_mode.html">ImportMode</a> mode=<a class="el" href="class__pytest_1_1pathlib_1_1_import_mode.html#a3c8859503e2fee8e08c242b769efe1b8">ImportMode.prepend</a>, Path root, bool consider_namespace_packages)</td></tr>
<tr class="separator:adbc8e461599c3d27cc24516ee5565e13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af158cc6a637b627de5fb10dc6d56dd53" id="r_af158cc6a637b627de5fb10dc6d56dd53"><td class="memItemLeft" align="right" valign="top">ModuleType|None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af158cc6a637b627de5fb10dc6d56dd53">_import_module_using_spec</a> (str module_name, Path module_path, Path module_location, *, bool insert_modules)</td></tr>
<tr class="separator:af158cc6a637b627de5fb10dc6d56dd53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a500b7dde594bf79fd876fcb912114d9f" id="r_a500b7dde594bf79fd876fcb912114d9f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a500b7dde594bf79fd876fcb912114d9f">spec_matches_module_path</a> (ModuleSpec|None module_spec, Path module_path)</td></tr>
<tr class="separator:a500b7dde594bf79fd876fcb912114d9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40b07abdf23e0fb0d65477da791e92ab" id="r_a40b07abdf23e0fb0d65477da791e92ab"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a40b07abdf23e0fb0d65477da791e92ab">_is_same</a> (str f1, str f2)</td></tr>
<tr class="separator:a40b07abdf23e0fb0d65477da791e92ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a627c18aa62422d2db2f1ad51382f5afd" id="r_a627c18aa62422d2db2f1ad51382f5afd"><td class="memItemLeft" align="right" valign="top">str&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a627c18aa62422d2db2f1ad51382f5afd">module_name_from_path</a> (Path path, Path root)</td></tr>
<tr class="separator:a627c18aa62422d2db2f1ad51382f5afd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acda9be6ad7371c8275fd7e08928726c5" id="r_acda9be6ad7371c8275fd7e08928726c5"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acda9be6ad7371c8275fd7e08928726c5">insert_missing_modules</a> (dict[str, ModuleType] modules, str module_name)</td></tr>
<tr class="separator:acda9be6ad7371c8275fd7e08928726c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca58c69dc664a8394910cb98591c2c3e" id="r_aca58c69dc664a8394910cb98591c2c3e"><td class="memItemLeft" align="right" valign="top">Path|None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aca58c69dc664a8394910cb98591c2c3e">resolve_package_path</a> (Path path)</td></tr>
<tr class="separator:aca58c69dc664a8394910cb98591c2c3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0d4d9c6518ac50dc96cac0b37d9ef7a" id="r_ae0d4d9c6518ac50dc96cac0b37d9ef7a"><td class="memItemLeft" align="right" valign="top">tuple[Path, str]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae0d4d9c6518ac50dc96cac0b37d9ef7a">resolve_pkg_root_and_module_name</a> (Path path, *, bool consider_namespace_packages=False)</td></tr>
<tr class="separator:ae0d4d9c6518ac50dc96cac0b37d9ef7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af40ce40c87f5e694865f40cbfa267f3c" id="r_af40ce40c87f5e694865f40cbfa267f3c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af40ce40c87f5e694865f40cbfa267f3c">is_importable</a> (str module_name, Path module_path)</td></tr>
<tr class="separator:af40ce40c87f5e694865f40cbfa267f3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95648f8e99507feb1f5978aaa70877f7" id="r_a95648f8e99507feb1f5978aaa70877f7"><td class="memItemLeft" align="right" valign="top">str|None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a95648f8e99507feb1f5978aaa70877f7">compute_module_name</a> (Path root, Path module_path)</td></tr>
<tr class="separator:a95648f8e99507feb1f5978aaa70877f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7902afd9185410d7886e257cfa28d6d0" id="r_a7902afd9185410d7886e257cfa28d6d0"><td class="memItemLeft" align="right" valign="top">list[os.DirEntry[str]]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7902afd9185410d7886e257cfa28d6d0">scandir</a> (str|os.PathLike[str] path, Callable[[os.DirEntry[str]], object] sort_key=lambda entry:entry.name)</td></tr>
<tr class="separator:a7902afd9185410d7886e257cfa28d6d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93c510d7d87a1bd007c78df762338f1e" id="r_a93c510d7d87a1bd007c78df762338f1e"><td class="memItemLeft" align="right" valign="top">Iterator[os.DirEntry[str]]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a93c510d7d87a1bd007c78df762338f1e">visit</a> (str|os.PathLike[str] path, Callable[[os.DirEntry[str]], bool] recurse)</td></tr>
<tr class="separator:a93c510d7d87a1bd007c78df762338f1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3711f7c9b726c90c56e71a74a6644153" id="r_a3711f7c9b726c90c56e71a74a6644153"><td class="memItemLeft" align="right" valign="top">Path&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3711f7c9b726c90c56e71a74a6644153">absolutepath</a> (str|os.PathLike[str] path)</td></tr>
<tr class="separator:a3711f7c9b726c90c56e71a74a6644153"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36570346e402c40e0ce5a83af6f33ab0" id="r_a36570346e402c40e0ce5a83af6f33ab0"><td class="memItemLeft" align="right" valign="top">Path|None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a36570346e402c40e0ce5a83af6f33ab0">commonpath</a> (Path path1, Path path2)</td></tr>
<tr class="separator:a36570346e402c40e0ce5a83af6f33ab0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a551b7399b00c9a5673964d7a3e299f2f" id="r_a551b7399b00c9a5673964d7a3e299f2f"><td class="memItemLeft" align="right" valign="top">str&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a551b7399b00c9a5673964d7a3e299f2f">bestrelpath</a> (Path directory, Path dest)</td></tr>
<tr class="separator:a551b7399b00c9a5673964d7a3e299f2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a477136b449c5773df097dd9410c8c3d1" id="r_a477136b449c5773df097dd9410c8c3d1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a477136b449c5773df097dd9410c8c3d1">safe_exists</a> (Path p)</td></tr>
<tr class="separator:a477136b449c5773df097dd9410c8c3d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a6c097e7a2732274f1e66f46e679d3fe2" id="r_a6c097e7a2732274f1e66f46e679d3fe2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6c097e7a2732274f1e66f46e679d3fe2">LOCK_TIMEOUT</a> = 60 * 60 * 24 * 3</td></tr>
<tr class="separator:a6c097e7a2732274f1e66f46e679d3fe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eaa54319ebbb1846a29cd4ad31da4d4" id="r_a0eaa54319ebbb1846a29cd4ad31da4d4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0eaa54319ebbb1846a29cd4ad31da4d4">_AnyPurePath</a> = TypeVar(&quot;_AnyPurePath&quot;, bound=PurePath)</td></tr>
<tr class="separator:a0eaa54319ebbb1846a29cd4ad31da4d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4098dd7db7f37942e4d1e4898051a34d" id="r_a4098dd7db7f37942e4d1e4898051a34d"><td class="memItemLeft" align="right" valign="top">tuple&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4098dd7db7f37942e4d1e4898051a34d">_IGNORED_ERRORS</a> = (ENOENT, ENOTDIR, EBADF, ELOOP)</td></tr>
<tr class="separator:a4098dd7db7f37942e4d1e4898051a34d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82dcc98dfd4f9e8e52ff548aaf17b6e8" id="r_a82dcc98dfd4f9e8e52ff548aaf17b6e8"><td class="memItemLeft" align="right" valign="top">tuple&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a82dcc98dfd4f9e8e52ff548aaf17b6e8">_IGNORED_WINERRORS</a></td></tr>
<tr class="separator:a82dcc98dfd4f9e8e52ff548aaf17b6e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a2d36d17900127934577a8859d235bcfd" name="a2d36d17900127934577a8859d235bcfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d36d17900127934577a8859d235bcfd">&#9670;&#160;</a></span>_force_symlink()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> None _pytest.pathlib._force_symlink </td>
          <td>(</td>
          <td class="paramtype">Path</td>          <td class="paramname"><span class="paramname"><em>root</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | PurePath</td>          <td class="paramname"><span class="paramname"><em>target</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | Path</td>          <td class="paramname"><span class="paramname"><em>link_to</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Helper to create the current symlink.

It's full of race conditions that are reasonably OK to ignore
for the context of best effort linking to the latest test run.

The presumption being that in case of much parallelism
the inaccuracy is going to be acceptable.
</pre> 
<p class="reference">Referenced by <a class="el" href="#a6ca62f92c9e61a349836eadf38245d85">_pytest.pathlib.make_numbered_dir()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace__pytest_1_1pathlib_a2d36d17900127934577a8859d235bcfd_icgraph.png" border="0" usemap="#anamespace__pytest_1_1pathlib_a2d36d17900127934577a8859d235bcfd_icgraph" alt=""/></div>
</div>

</div>
</div>
<a id="a49fb18e734de79bf93247d67a201673b" name="a49fb18e734de79bf93247d67a201673b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49fb18e734de79bf93247d67a201673b">&#9670;&#160;</a></span>_ignore_error()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> bool _pytest.pathlib._ignore_error </td>
          <td>(</td>
          <td class="paramtype">Exception</td>          <td class="paramname"><span class="paramname"><em>exception</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af158cc6a637b627de5fb10dc6d56dd53" name="af158cc6a637b627de5fb10dc6d56dd53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af158cc6a637b627de5fb10dc6d56dd53">&#9670;&#160;</a></span>_import_module_using_spec()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> ModuleType | None _pytest.pathlib._import_module_using_spec </td>
          <td>(</td>
          <td class="paramtype">str</td>          <td class="paramname"><span class="paramname"><em>module_name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Path</td>          <td class="paramname"><span class="paramname"><em>module_path</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Path</td>          <td class="paramname"><span class="paramname"><em>module_location</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool
</td>          <td class="paramname"><span class="paramname"><em>insert_modules</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Tries to import a module by its canonical name, path to the .py file, and its
parent location.

:param insert_modules:
    If True, will call insert_missing_modules to create empty intermediate modules
    for made-up module names (when importing test files not reachable from sys.path).
</pre> 
<p class="reference">References <a class="el" href="#af158cc6a637b627de5fb10dc6d56dd53">_pytest.pathlib._import_module_using_spec()</a>, <a class="el" href="#acda9be6ad7371c8275fd7e08928726c5">_pytest.pathlib.insert_missing_modules()</a>, and <a class="el" href="#a500b7dde594bf79fd876fcb912114d9f">_pytest.pathlib.spec_matches_module_path()</a>.</p>

<p class="reference">Referenced by <a class="el" href="#af158cc6a637b627de5fb10dc6d56dd53">_pytest.pathlib._import_module_using_spec()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace__pytest_1_1pathlib_af158cc6a637b627de5fb10dc6d56dd53_cgraph.png" border="0" usemap="#anamespace__pytest_1_1pathlib_af158cc6a637b627de5fb10dc6d56dd53_cgraph" alt=""/></div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace__pytest_1_1pathlib_af158cc6a637b627de5fb10dc6d56dd53_icgraph.png" border="0" usemap="#anamespace__pytest_1_1pathlib_af158cc6a637b627de5fb10dc6d56dd53_icgraph" alt=""/></div>
</div>

</div>
</div>
<a id="a40b07abdf23e0fb0d65477da791e92ab" name="a40b07abdf23e0fb0d65477da791e92ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40b07abdf23e0fb0d65477da791e92ab">&#9670;&#160;</a></span>_is_same()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool _pytest.pathlib._is_same </td>
          <td>(</td>
          <td class="paramtype">str</td>          <td class="paramname"><span class="paramname"><em>f1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str</td>          <td class="paramname"><span class="paramname"><em>f2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3711f7c9b726c90c56e71a74a6644153" name="a3711f7c9b726c90c56e71a74a6644153"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3711f7c9b726c90c56e71a74a6644153">&#9670;&#160;</a></span>absolutepath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Path _pytest.pathlib.absolutepath </td>
          <td>(</td>
          <td class="paramtype">str | os.PathLike[str]</td>          <td class="paramname"><span class="paramname"><em>path</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Convert a path to an absolute path using os.path.abspath.

Prefer this over Path.resolve() (see #6523).
Prefer this over Path.absolute() (not public, doesn't normalize).
</pre> 
</div>
</div>
<a id="a551b7399b00c9a5673964d7a3e299f2f" name="a551b7399b00c9a5673964d7a3e299f2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a551b7399b00c9a5673964d7a3e299f2f">&#9670;&#160;</a></span>bestrelpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> str _pytest.pathlib.bestrelpath </td>
          <td>(</td>
          <td class="paramtype">Path</td>          <td class="paramname"><span class="paramname"><em>directory</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Path</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a string which is a relative path from directory to dest such
that directory/bestrelpath == dest.

The paths must be either both absolute or both relative.

If no such path can be determined, returns dest.
</pre> 
</div>
</div>
<a id="ae357103ea4a06ecb2d8bd3b18af4ea53" name="ae357103ea4a06ecb2d8bd3b18af4ea53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae357103ea4a06ecb2d8bd3b18af4ea53">&#9670;&#160;</a></span>cleanup_candidates()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Iterator[Path] _pytest.pathlib.cleanup_candidates </td>
          <td>(</td>
          <td class="paramtype">Path</td>          <td class="paramname"><span class="paramname"><em>root</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str</td>          <td class="paramname"><span class="paramname"><em>prefix</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>keep</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">List candidates for numbered directories to be removed - follows py.path.</pre> 
<p class="reference">References <a class="el" href="#a0addba70a654b247e36cb4401bc7dc12">_pytest.pathlib.extract_suffixes()</a>, <a class="el" href="#ab1843653a064d8dee4dcf9a5cc00679c">_pytest.pathlib.find_prefixed()</a>, and <a class="el" href="#ae5a66215e40cad20f751eddc3c6e8721">_pytest.pathlib.find_suffixes()</a>.</p>

<p class="reference">Referenced by <a class="el" href="#a9d1e52490b7f908dbc8b6041d0bba697">_pytest.pathlib.cleanup_numbered_dir()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace__pytest_1_1pathlib_ae357103ea4a06ecb2d8bd3b18af4ea53_cgraph.png" border="0" usemap="#anamespace__pytest_1_1pathlib_ae357103ea4a06ecb2d8bd3b18af4ea53_cgraph" alt=""/></div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace__pytest_1_1pathlib_ae357103ea4a06ecb2d8bd3b18af4ea53_icgraph.png" border="0" usemap="#anamespace__pytest_1_1pathlib_ae357103ea4a06ecb2d8bd3b18af4ea53_icgraph" alt=""/></div>
</div>

</div>
</div>
<a id="a029804adc1a9bf460f063bad46dade6a" name="a029804adc1a9bf460f063bad46dade6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a029804adc1a9bf460f063bad46dade6a">&#9670;&#160;</a></span>cleanup_dead_symlinks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None _pytest.pathlib.cleanup_dead_symlinks </td>
          <td>(</td>
          <td class="paramtype">Path</td>          <td class="paramname"><span class="paramname"><em>root</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9d1e52490b7f908dbc8b6041d0bba697" name="a9d1e52490b7f908dbc8b6041d0bba697"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d1e52490b7f908dbc8b6041d0bba697">&#9670;&#160;</a></span>cleanup_numbered_dir()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None _pytest.pathlib.cleanup_numbered_dir </td>
          <td>(</td>
          <td class="paramtype">Path</td>          <td class="paramname"><span class="paramname"><em>root</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str</td>          <td class="paramname"><span class="paramname"><em>prefix</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>keep</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float
</td>          <td class="paramname"><span class="paramname"><em>consider_lock_dead_if_created_before</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Cleanup for lock driven numbered directories.</pre> 
<p class="reference">References <a class="el" href="#ae357103ea4a06ecb2d8bd3b18af4ea53">_pytest.pathlib.cleanup_candidates()</a>, and <a class="el" href="#a94a716332cee4b0ffe6806ccfd56c390">_pytest.pathlib.try_cleanup()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace__pytest_1_1pathlib_a9d1e52490b7f908dbc8b6041d0bba697_cgraph.png" border="0" usemap="#anamespace__pytest_1_1pathlib_a9d1e52490b7f908dbc8b6041d0bba697_cgraph" alt=""/></div>
</div>

</div>
</div>
<a id="a36570346e402c40e0ce5a83af6f33ab0" name="a36570346e402c40e0ce5a83af6f33ab0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36570346e402c40e0ce5a83af6f33ab0">&#9670;&#160;</a></span>commonpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Path | None _pytest.pathlib.commonpath </td>
          <td>(</td>
          <td class="paramtype">Path</td>          <td class="paramname"><span class="paramname"><em>path1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Path</td>          <td class="paramname"><span class="paramname"><em>path2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the common part shared with the other path, or None if there is
no common part.

If one path is relative and one is absolute, returns None.
</pre> 
</div>
</div>
<a id="a95648f8e99507feb1f5978aaa70877f7" name="a95648f8e99507feb1f5978aaa70877f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95648f8e99507feb1f5978aaa70877f7">&#9670;&#160;</a></span>compute_module_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> str | None _pytest.pathlib.compute_module_name </td>
          <td>(</td>
          <td class="paramtype">Path</td>          <td class="paramname"><span class="paramname"><em>root</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Path</td>          <td class="paramname"><span class="paramname"><em>module_path</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute a module name based on a path and a root anchor.</pre> 
<p class="reference">Referenced by <a class="el" href="#ae0d4d9c6518ac50dc96cac0b37d9ef7a">_pytest.pathlib.resolve_pkg_root_and_module_name()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace__pytest_1_1pathlib_a95648f8e99507feb1f5978aaa70877f7_icgraph.png" border="0" usemap="#anamespace__pytest_1_1pathlib_a95648f8e99507feb1f5978aaa70877f7_icgraph" alt=""/></div>
</div>

</div>
</div>
<a id="a2fae1b99c0fbb9d314aceb95e668a401" name="a2fae1b99c0fbb9d314aceb95e668a401"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fae1b99c0fbb9d314aceb95e668a401">&#9670;&#160;</a></span>create_cleanup_lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Path _pytest.pathlib.create_cleanup_lock </td>
          <td>(</td>
          <td class="paramtype">Path</td>          <td class="paramname"><span class="paramname"><em>p</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Create a lock to prevent premature folder cleanup.</pre> 
<p class="reference">References <a class="el" href="#a71cc9f2b91e8d7c2f31e80cc596fc1ad">_pytest.pathlib.get_lock_path()</a>.</p>

<p class="reference">Referenced by <a class="el" href="#a31cda2f173f0946adac7122c00608b88">_pytest.pathlib.make_numbered_dir_with_cleanup()</a>, and <a class="el" href="#a13e58fca02f174fa9bd72475840e51cc">_pytest.pathlib.maybe_delete_a_numbered_dir()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace__pytest_1_1pathlib_a2fae1b99c0fbb9d314aceb95e668a401_cgraph.png" border="0" usemap="#anamespace__pytest_1_1pathlib_a2fae1b99c0fbb9d314aceb95e668a401_cgraph" alt=""/></div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace__pytest_1_1pathlib_a2fae1b99c0fbb9d314aceb95e668a401_icgraph.png" border="0" usemap="#anamespace__pytest_1_1pathlib_a2fae1b99c0fbb9d314aceb95e668a401_icgraph" alt=""/></div>
</div>

</div>
</div>
<a id="a1c3f573b2bcd340dc200f85899715bfa" name="a1c3f573b2bcd340dc200f85899715bfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c3f573b2bcd340dc200f85899715bfa">&#9670;&#160;</a></span>ensure_deletable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> bool _pytest.pathlib.ensure_deletable </td>
          <td>(</td>
          <td class="paramtype">Path</td>          <td class="paramname"><span class="paramname"><em>path</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>consider_lock_dead_if_created_before</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Check if `path` is deletable based on whether the lock file is expired.</pre> 
<p class="reference">References <a class="el" href="#a71cc9f2b91e8d7c2f31e80cc596fc1ad">_pytest.pathlib.get_lock_path()</a>.</p>

<p class="reference">Referenced by <a class="el" href="#a94a716332cee4b0ffe6806ccfd56c390">_pytest.pathlib.try_cleanup()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace__pytest_1_1pathlib_a1c3f573b2bcd340dc200f85899715bfa_cgraph.png" border="0" usemap="#anamespace__pytest_1_1pathlib_a1c3f573b2bcd340dc200f85899715bfa_cgraph" alt=""/></div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace__pytest_1_1pathlib_a1c3f573b2bcd340dc200f85899715bfa_icgraph.png" border="0" usemap="#anamespace__pytest_1_1pathlib_a1c3f573b2bcd340dc200f85899715bfa_icgraph" alt=""/></div>
</div>

</div>
</div>
<a id="a6b8b0325e6efac0c038f9a724ab8a2bf" name="a6b8b0325e6efac0c038f9a724ab8a2bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b8b0325e6efac0c038f9a724ab8a2bf">&#9670;&#160;</a></span>ensure_extended_length_path()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Path _pytest.pathlib.ensure_extended_length_path </td>
          <td>(</td>
          <td class="paramtype">Path</td>          <td class="paramname"><span class="paramname"><em>path</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Get the extended-length version of a path (Windows).

On Windows, by default, the maximum length of a path (MAX_PATH) is 260
characters, and operations on paths longer than that fail. But it is possible
to overcome this by converting the path to "extended-length" form before
performing the operation:
https://docs.microsoft.com/en-us/windows/win32/fileio/naming-a-file#maximum-path-length-limitation

On Windows, this function returns the extended-length absolute version of path.
On other platforms it returns path unchanged.
</pre> 
<p class="reference">References <a class="el" href="#ae544da450e5c7c6870a70be7cabc75d8">_pytest.pathlib.get_extended_length_path_str()</a>.</p>

<p class="reference">Referenced by <a class="el" href="#a13e58fca02f174fa9bd72475840e51cc">_pytest.pathlib.maybe_delete_a_numbered_dir()</a>, and <a class="el" href="#ae1f0c08537ab64dd461cfb6674625b38">_pytest.pathlib.rm_rf()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace__pytest_1_1pathlib_a6b8b0325e6efac0c038f9a724ab8a2bf_cgraph.png" border="0" usemap="#anamespace__pytest_1_1pathlib_a6b8b0325e6efac0c038f9a724ab8a2bf_cgraph" alt=""/></div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace__pytest_1_1pathlib_a6b8b0325e6efac0c038f9a724ab8a2bf_icgraph.png" border="0" usemap="#anamespace__pytest_1_1pathlib_a6b8b0325e6efac0c038f9a724ab8a2bf_icgraph" alt=""/></div>
</div>

</div>
</div>
<a id="a0addba70a654b247e36cb4401bc7dc12" name="a0addba70a654b247e36cb4401bc7dc12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0addba70a654b247e36cb4401bc7dc12">&#9670;&#160;</a></span>extract_suffixes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Iterator[str] _pytest.pathlib.extract_suffixes </td>
          <td>(</td>
          <td class="paramtype">Iterable[os.DirEntry[str]]</td>          <td class="paramname"><span class="paramname"><em>iter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str</td>          <td class="paramname"><span class="paramname"><em>prefix</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the parts of the paths following the prefix.

:param iter: Iterator over path names.
:param prefix: Expected prefix of the path names.
</pre> 
<p class="reference">Referenced by <a class="el" href="#ae357103ea4a06ecb2d8bd3b18af4ea53">_pytest.pathlib.cleanup_candidates()</a>, and <a class="el" href="#ae5a66215e40cad20f751eddc3c6e8721">_pytest.pathlib.find_suffixes()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace__pytest_1_1pathlib_a0addba70a654b247e36cb4401bc7dc12_icgraph.png" border="0" usemap="#anamespace__pytest_1_1pathlib_a0addba70a654b247e36cb4401bc7dc12_icgraph" alt=""/></div>
</div>

</div>
</div>
<a id="ab1843653a064d8dee4dcf9a5cc00679c" name="ab1843653a064d8dee4dcf9a5cc00679c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1843653a064d8dee4dcf9a5cc00679c">&#9670;&#160;</a></span>find_prefixed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Iterator[os.DirEntry[str]] _pytest.pathlib.find_prefixed </td>
          <td>(</td>
          <td class="paramtype">Path</td>          <td class="paramname"><span class="paramname"><em>root</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str</td>          <td class="paramname"><span class="paramname"><em>prefix</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Find all elements in root that begin with the prefix, case-insensitive.</pre> 
<p class="reference">Referenced by <a class="el" href="#ae357103ea4a06ecb2d8bd3b18af4ea53">_pytest.pathlib.cleanup_candidates()</a>, and <a class="el" href="#ae5a66215e40cad20f751eddc3c6e8721">_pytest.pathlib.find_suffixes()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace__pytest_1_1pathlib_ab1843653a064d8dee4dcf9a5cc00679c_icgraph.png" border="0" usemap="#anamespace__pytest_1_1pathlib_ab1843653a064d8dee4dcf9a5cc00679c_icgraph" alt=""/></div>
</div>

</div>
</div>
<a id="ae5a66215e40cad20f751eddc3c6e8721" name="ae5a66215e40cad20f751eddc3c6e8721"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5a66215e40cad20f751eddc3c6e8721">&#9670;&#160;</a></span>find_suffixes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Iterator[str] _pytest.pathlib.find_suffixes </td>
          <td>(</td>
          <td class="paramtype">Path</td>          <td class="paramname"><span class="paramname"><em>root</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str</td>          <td class="paramname"><span class="paramname"><em>prefix</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Combine find_prefixes and extract_suffixes.</pre> 
<p class="reference">References <a class="el" href="#a0addba70a654b247e36cb4401bc7dc12">_pytest.pathlib.extract_suffixes()</a>, and <a class="el" href="#ab1843653a064d8dee4dcf9a5cc00679c">_pytest.pathlib.find_prefixed()</a>.</p>

<p class="reference">Referenced by <a class="el" href="#ae357103ea4a06ecb2d8bd3b18af4ea53">_pytest.pathlib.cleanup_candidates()</a>, and <a class="el" href="#a6ca62f92c9e61a349836eadf38245d85">_pytest.pathlib.make_numbered_dir()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace__pytest_1_1pathlib_ae5a66215e40cad20f751eddc3c6e8721_cgraph.png" border="0" usemap="#anamespace__pytest_1_1pathlib_ae5a66215e40cad20f751eddc3c6e8721_cgraph" alt=""/></div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace__pytest_1_1pathlib_ae5a66215e40cad20f751eddc3c6e8721_icgraph.png" border="0" usemap="#anamespace__pytest_1_1pathlib_ae5a66215e40cad20f751eddc3c6e8721_icgraph" alt=""/></div>
</div>

</div>
</div>
<a id="a6b1004d7bebd54d347c235848846e2e8" name="a6b1004d7bebd54d347c235848846e2e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b1004d7bebd54d347c235848846e2e8">&#9670;&#160;</a></span>fnmatch_ex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> bool _pytest.pathlib.fnmatch_ex </td>
          <td>(</td>
          <td class="paramtype">str</td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | os.PathLike[str]</td>          <td class="paramname"><span class="paramname"><em>path</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">A port of FNMatcher from py.path.common which works with PurePath() instances.

The difference between this algorithm and PurePath.match() is that the
latter matches "**" glob expressions for each part of the path, while
this algorithm uses the whole path instead.

For example:
    "tests/foo/bar/doc/test_foo.py" matches pattern "tests/**/doc/test*.py"
    with this algorithm, but not with PurePath.match().

This algorithm was ported to keep backward-compatibility with existing
settings which assume paths match according this logic.

References:
* https://bugs.python.org/issue29249
* https://bugs.python.org/issue34731
</pre> 
</div>
</div>
<a id="ae544da450e5c7c6870a70be7cabc75d8" name="ae544da450e5c7c6870a70be7cabc75d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae544da450e5c7c6870a70be7cabc75d8">&#9670;&#160;</a></span>get_extended_length_path_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> str _pytest.pathlib.get_extended_length_path_str </td>
          <td>(</td>
          <td class="paramtype">str</td>          <td class="paramname"><span class="paramname"><em>path</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Convert a path to a Windows extended length path.</pre> 
<p class="reference">Referenced by <a class="el" href="#a6b8b0325e6efac0c038f9a724ab8a2bf">_pytest.pathlib.ensure_extended_length_path()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace__pytest_1_1pathlib_ae544da450e5c7c6870a70be7cabc75d8_icgraph.png" border="0" usemap="#anamespace__pytest_1_1pathlib_ae544da450e5c7c6870a70be7cabc75d8_icgraph" alt=""/></div>
</div>

</div>
</div>
<a id="a71cc9f2b91e8d7c2f31e80cc596fc1ad" name="a71cc9f2b91e8d7c2f31e80cc596fc1ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71cc9f2b91e8d7c2f31e80cc596fc1ad">&#9670;&#160;</a></span>get_lock_path()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="#a0eaa54319ebbb1846a29cd4ad31da4d4">_AnyPurePath</a> _pytest.pathlib.get_lock_path </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a0eaa54319ebbb1846a29cd4ad31da4d4">_AnyPurePath</a></td>          <td class="paramname"><span class="paramname"><em>path</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="#a2fae1b99c0fbb9d314aceb95e668a401">_pytest.pathlib.create_cleanup_lock()</a>, and <a class="el" href="#a1c3f573b2bcd340dc200f85899715bfa">_pytest.pathlib.ensure_deletable()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace__pytest_1_1pathlib_a71cc9f2b91e8d7c2f31e80cc596fc1ad_icgraph.png" border="0" usemap="#anamespace__pytest_1_1pathlib_a71cc9f2b91e8d7c2f31e80cc596fc1ad_icgraph" alt=""/></div>
</div>

</div>
</div>
<a id="adbc8e461599c3d27cc24516ee5565e13" name="adbc8e461599c3d27cc24516ee5565e13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbc8e461599c3d27cc24516ee5565e13">&#9670;&#160;</a></span>import_path()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> ModuleType _pytest.pathlib.import_path </td>
          <td>(</td>
          <td class="paramtype">str | os.PathLike[str]</td>          <td class="paramname"><span class="paramname"><em>path</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | <a class="el" href="class__pytest_1_1pathlib_1_1_import_mode.html">ImportMode</a> </td>          <td class="paramname"><span class="paramname"><em>mode</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="class__pytest_1_1pathlib_1_1_import_mode.html#a3c8859503e2fee8e08c242b769efe1b8">ImportMode.prepend</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Path</td>          <td class="paramname"><span class="paramname"><em>root</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>consider_namespace_packages</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Import and return a module from the given path, which can be a file (a module) or
a directory (a package).

:param path:
    Path to the file to import.

:param mode:
    Controls the underlying import mechanism that will be used:

    * ImportMode.prepend: the directory containing the module (or package, taking
      `__init__.py` files into account) will be put at the *start* of `sys.path` before
      being imported with `importlib.import_module`.

    * ImportMode.append: same as `prepend`, but the directory will be appended
      to the end of `sys.path`, if not already in `sys.path`.

    * ImportMode.importlib: uses more fine control mechanisms provided by `importlib`
      to import the module, which avoids having to muck with `sys.path` at all. It effectively
      allows having same-named test modules in different places.

:param root:
    Used as an anchor when mode == ImportMode.importlib to obtain
    a unique name for the module being imported so it can safely be stored
    into ``sys.modules``.

:param consider_namespace_packages:
    If True, consider namespace packages when resolving module names.

:raises ImportPathMismatchError:
    If after importing the given `path` and the module `__file__`
    are different. Only raised in `prepend` and `append` modes.
</pre> 
</div>
</div>
<a id="acda9be6ad7371c8275fd7e08928726c5" name="acda9be6ad7371c8275fd7e08928726c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acda9be6ad7371c8275fd7e08928726c5">&#9670;&#160;</a></span>insert_missing_modules()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None _pytest.pathlib.insert_missing_modules </td>
          <td>(</td>
          <td class="paramtype">dict[str, ModuleType]</td>          <td class="paramname"><span class="paramname"><em>modules</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str</td>          <td class="paramname"><span class="paramname"><em>module_name</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Used by ``import_path`` to create intermediate modules when using mode=importlib.

When we want to import a module as "src.tests.test_foo" for example, we need
to create empty modules "src" and "src.tests" after inserting "src.tests.test_foo",
otherwise "src.tests.test_foo" is not importable by ``__import__``.
</pre> 
<p class="reference">Referenced by <a class="el" href="#af158cc6a637b627de5fb10dc6d56dd53">_pytest.pathlib._import_module_using_spec()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace__pytest_1_1pathlib_acda9be6ad7371c8275fd7e08928726c5_icgraph.png" border="0" usemap="#anamespace__pytest_1_1pathlib_acda9be6ad7371c8275fd7e08928726c5_icgraph" alt=""/></div>
</div>

</div>
</div>
<a id="af40ce40c87f5e694865f40cbfa267f3c" name="af40ce40c87f5e694865f40cbfa267f3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af40ce40c87f5e694865f40cbfa267f3c">&#9670;&#160;</a></span>is_importable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> bool _pytest.pathlib.is_importable </td>
          <td>(</td>
          <td class="paramtype">str</td>          <td class="paramname"><span class="paramname"><em>module_name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Path</td>          <td class="paramname"><span class="paramname"><em>module_path</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return if the given module path could be imported normally by Python, akin to the user
entering the REPL and importing the corresponding module name directly, and corresponds
to the module_path specified.

:param module_name:
    Full module name that we want to check if is importable.
    For example, "app.models".

:param module_path:
    Full path to the python module/package we want to check if is importable.
    For example, "/projects/src/app/models.py".
</pre> 
<p class="reference">References <a class="el" href="#a500b7dde594bf79fd876fcb912114d9f">_pytest.pathlib.spec_matches_module_path()</a>.</p>

<p class="reference">Referenced by <a class="el" href="#ae0d4d9c6518ac50dc96cac0b37d9ef7a">_pytest.pathlib.resolve_pkg_root_and_module_name()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace__pytest_1_1pathlib_af40ce40c87f5e694865f40cbfa267f3c_cgraph.png" border="0" usemap="#anamespace__pytest_1_1pathlib_af40ce40c87f5e694865f40cbfa267f3c_cgraph" alt=""/></div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace__pytest_1_1pathlib_af40ce40c87f5e694865f40cbfa267f3c_icgraph.png" border="0" usemap="#anamespace__pytest_1_1pathlib_af40ce40c87f5e694865f40cbfa267f3c_icgraph" alt=""/></div>
</div>

</div>
</div>
<a id="a6ca62f92c9e61a349836eadf38245d85" name="a6ca62f92c9e61a349836eadf38245d85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ca62f92c9e61a349836eadf38245d85">&#9670;&#160;</a></span>make_numbered_dir()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Path _pytest.pathlib.make_numbered_dir </td>
          <td>(</td>
          <td class="paramtype">Path</td>          <td class="paramname"><span class="paramname"><em>root</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str</td>          <td class="paramname"><span class="paramname"><em>prefix</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>          <td class="paramname"><span class="paramname"><em>mode</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0o700</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Create a directory with an increased number as suffix for the given prefix.</pre> 
<p class="reference">References <a class="el" href="#a2d36d17900127934577a8859d235bcfd">_pytest.pathlib._force_symlink()</a>, and <a class="el" href="#ae5a66215e40cad20f751eddc3c6e8721">_pytest.pathlib.find_suffixes()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace__pytest_1_1pathlib_a6ca62f92c9e61a349836eadf38245d85_cgraph.png" border="0" usemap="#anamespace__pytest_1_1pathlib_a6ca62f92c9e61a349836eadf38245d85_cgraph" alt=""/></div>
</div>

</div>
</div>
<a id="a31cda2f173f0946adac7122c00608b88" name="a31cda2f173f0946adac7122c00608b88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31cda2f173f0946adac7122c00608b88">&#9670;&#160;</a></span>make_numbered_dir_with_cleanup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Path _pytest.pathlib.make_numbered_dir_with_cleanup </td>
          <td>(</td>
          <td class="paramtype">Path</td>          <td class="paramname"><span class="paramname"><em>root</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str</td>          <td class="paramname"><span class="paramname"><em>prefix</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>keep</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>lock_timeout</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>mode</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Create a numbered dir with a cleanup lock and remove old ones.</pre> 
<p class="reference">References <a class="el" href="#a2fae1b99c0fbb9d314aceb95e668a401">_pytest.pathlib.create_cleanup_lock()</a>, and <a class="el" href="#a18e8d477b40f4178236b4e1a1465e550">_pytest.pathlib.register_cleanup_lock_removal()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace__pytest_1_1pathlib_a31cda2f173f0946adac7122c00608b88_cgraph.png" border="0" usemap="#anamespace__pytest_1_1pathlib_a31cda2f173f0946adac7122c00608b88_cgraph" alt=""/></div>
</div>

</div>
</div>
<a id="a13e58fca02f174fa9bd72475840e51cc" name="a13e58fca02f174fa9bd72475840e51cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13e58fca02f174fa9bd72475840e51cc">&#9670;&#160;</a></span>maybe_delete_a_numbered_dir()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None _pytest.pathlib.maybe_delete_a_numbered_dir </td>
          <td>(</td>
          <td class="paramtype">Path</td>          <td class="paramname"><span class="paramname"><em>path</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Remove a numbered directory if its lock can be obtained and it does
not seem to be in use.</pre> 
<p class="reference">References <a class="el" href="#a2fae1b99c0fbb9d314aceb95e668a401">_pytest.pathlib.create_cleanup_lock()</a>, and <a class="el" href="#a6b8b0325e6efac0c038f9a724ab8a2bf">_pytest.pathlib.ensure_extended_length_path()</a>.</p>

<p class="reference">Referenced by <a class="el" href="#a94a716332cee4b0ffe6806ccfd56c390">_pytest.pathlib.try_cleanup()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace__pytest_1_1pathlib_a13e58fca02f174fa9bd72475840e51cc_cgraph.png" border="0" usemap="#anamespace__pytest_1_1pathlib_a13e58fca02f174fa9bd72475840e51cc_cgraph" alt=""/></div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace__pytest_1_1pathlib_a13e58fca02f174fa9bd72475840e51cc_icgraph.png" border="0" usemap="#anamespace__pytest_1_1pathlib_a13e58fca02f174fa9bd72475840e51cc_icgraph" alt=""/></div>
</div>

</div>
</div>
<a id="a627c18aa62422d2db2f1ad51382f5afd" name="a627c18aa62422d2db2f1ad51382f5afd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a627c18aa62422d2db2f1ad51382f5afd">&#9670;&#160;</a></span>module_name_from_path()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> str _pytest.pathlib.module_name_from_path </td>
          <td>(</td>
          <td class="paramtype">Path</td>          <td class="paramname"><span class="paramname"><em>path</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Path</td>          <td class="paramname"><span class="paramname"><em>root</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a dotted module name based on the given path, anchored on root.

For example: path="projects/src/tests/test_foo.py" and root="/projects", the
resulting module name will be "src.tests.test_foo".
</pre> 
</div>
</div>
<a id="a230d9829caff4723397aee03ddadc7ae" name="a230d9829caff4723397aee03ddadc7ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a230d9829caff4723397aee03ddadc7ae">&#9670;&#160;</a></span>on_rm_rf_error()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> bool _pytest.pathlib.on_rm_rf_error </td>
          <td>(</td>
          <td class="paramtype">Callable[..., Any] | None</td>          <td class="paramname"><span class="paramname"><em>func</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str</td>          <td class="paramname"><span class="paramname"><em>path</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BaseException
    | tuple[type[BaseException], BaseException, types.TracebackType | None]</td>          <td class="paramname"><span class="paramname"><em>excinfo</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Path</td>          <td class="paramname"><span class="paramname"><em>start_path</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Handle known read-only errors during rmtree.

The returned value is used only by our own tests.
</pre> 
</div>
</div>
<a id="aef6232b74550a186a8206597eefc3737" name="aef6232b74550a186a8206597eefc3737"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef6232b74550a186a8206597eefc3737">&#9670;&#160;</a></span>parse_num()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> int _pytest.pathlib.parse_num </td>
          <td>(</td>
          <td class="paramtype">str</td>          <td class="paramname"><span class="paramname"><em>maybe_num</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Parse number path suffixes, returns -1 on error.</pre> 
</div>
</div>
<a id="afb98e10060724ec1d7bcffc434ee55d8" name="afb98e10060724ec1d7bcffc434ee55d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb98e10060724ec1d7bcffc434ee55d8">&#9670;&#160;</a></span>parts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> set[str] _pytest.pathlib.parts </td>
          <td>(</td>
          <td class="paramtype">str</td>          <td class="paramname"><span class="paramname"><em>s</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a18e8d477b40f4178236b4e1a1465e550" name="a18e8d477b40f4178236b4e1a1465e550"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18e8d477b40f4178236b4e1a1465e550">&#9670;&#160;</a></span>register_cleanup_lock_removal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Any _pytest.pathlib.register_cleanup_lock_removal </td>
          <td>(</td>
          <td class="paramtype">Path</td>          <td class="paramname"><span class="paramname"><em>lock_path</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Any </td>          <td class="paramname"><span class="paramname"><em>register</em></span><span class="paramdefsep"> = </span><span class="paramdefval">atexit.register</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Register a cleanup function for removing a lock, by default on atexit.</pre> 
<p class="reference">Referenced by <a class="el" href="#a31cda2f173f0946adac7122c00608b88">_pytest.pathlib.make_numbered_dir_with_cleanup()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace__pytest_1_1pathlib_a18e8d477b40f4178236b4e1a1465e550_icgraph.png" border="0" usemap="#anamespace__pytest_1_1pathlib_a18e8d477b40f4178236b4e1a1465e550_icgraph" alt=""/></div>
</div>

</div>
</div>
<a id="a16d692771185c792d8b0f888953061d9" name="a16d692771185c792d8b0f888953061d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16d692771185c792d8b0f888953061d9">&#9670;&#160;</a></span>resolve_from_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Path _pytest.pathlib.resolve_from_str </td>
          <td>(</td>
          <td class="paramtype">str</td>          <td class="paramname"><span class="paramname"><em>input</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Path</td>          <td class="paramname"><span class="paramname"><em>rootpath</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aca58c69dc664a8394910cb98591c2c3e" name="aca58c69dc664a8394910cb98591c2c3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca58c69dc664a8394910cb98591c2c3e">&#9670;&#160;</a></span>resolve_package_path()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Path | None _pytest.pathlib.resolve_package_path </td>
          <td>(</td>
          <td class="paramtype">Path</td>          <td class="paramname"><span class="paramname"><em>path</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the Python package path by looking for the last
directory upwards which still contains an __init__.py.

Returns None if it cannot be determined.
</pre> 
</div>
</div>
<a id="ae0d4d9c6518ac50dc96cac0b37d9ef7a" name="ae0d4d9c6518ac50dc96cac0b37d9ef7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0d4d9c6518ac50dc96cac0b37d9ef7a">&#9670;&#160;</a></span>resolve_pkg_root_and_module_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> tuple[Path, str] _pytest.pathlib.resolve_pkg_root_and_module_name </td>
          <td>(</td>
          <td class="paramtype">Path</td>          <td class="paramname"><span class="paramname"><em>path</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool </td>          <td class="paramname"><span class="paramname"><em>consider_namespace_packages</em></span><span class="paramdefsep"> = </span><span class="paramdefval">False</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the path to the directory of the root package that contains the
given Python file, and its module name:

    src/
        app/
            __init__.py
            core/
                __init__.py
                models.py

Passing the full path to `models.py` will yield Path("src") and "app.core.models".

If consider_namespace_packages is True, then we additionally check upwards in the hierarchy
for namespace packages:

https://packaging.python.org/en/latest/guides/packaging-namespace-packages

Raises CouldNotResolvePathError if the given path does not belong to a package (missing any __init__.py files).
</pre> 
<p class="reference">References <a class="el" href="#a95648f8e99507feb1f5978aaa70877f7">_pytest.pathlib.compute_module_name()</a>, and <a class="el" href="#af40ce40c87f5e694865f40cbfa267f3c">_pytest.pathlib.is_importable()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace__pytest_1_1pathlib_ae0d4d9c6518ac50dc96cac0b37d9ef7a_cgraph.png" border="0" usemap="#anamespace__pytest_1_1pathlib_ae0d4d9c6518ac50dc96cac0b37d9ef7a_cgraph" alt=""/></div>
</div>

</div>
</div>
<a id="ae1f0c08537ab64dd461cfb6674625b38" name="ae1f0c08537ab64dd461cfb6674625b38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1f0c08537ab64dd461cfb6674625b38">&#9670;&#160;</a></span>rm_rf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None _pytest.pathlib.rm_rf </td>
          <td>(</td>
          <td class="paramtype">Path</td>          <td class="paramname"><span class="paramname"><em>path</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Remove the path contents recursively, even if some elements
are read-only.</pre> 
<p class="reference">References <a class="el" href="#a6b8b0325e6efac0c038f9a724ab8a2bf">_pytest.pathlib.ensure_extended_length_path()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace__pytest_1_1pathlib_ae1f0c08537ab64dd461cfb6674625b38_cgraph.png" border="0" usemap="#anamespace__pytest_1_1pathlib_ae1f0c08537ab64dd461cfb6674625b38_cgraph" alt=""/></div>
</div>

</div>
</div>
<a id="a477136b449c5773df097dd9410c8c3d1" name="a477136b449c5773df097dd9410c8c3d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a477136b449c5773df097dd9410c8c3d1">&#9670;&#160;</a></span>safe_exists()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> bool _pytest.pathlib.safe_exists </td>
          <td>(</td>
          <td class="paramtype">Path</td>          <td class="paramname"><span class="paramname"><em>p</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Like Path.exists(), but account for input arguments that might be too long (#11394).</pre> 
</div>
</div>
<a id="a7902afd9185410d7886e257cfa28d6d0" name="a7902afd9185410d7886e257cfa28d6d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7902afd9185410d7886e257cfa28d6d0">&#9670;&#160;</a></span>scandir()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> list[os.DirEntry[str]] _pytest.pathlib.scandir </td>
          <td>(</td>
          <td class="paramtype">str | os.PathLike[str]</td>          <td class="paramname"><span class="paramname"><em>path</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Callable[[os.DirEntry[str]], object] </td>          <td class="paramname"><span class="paramname"><em>sort_key</em></span><span class="paramdefsep"> = </span><span class="paramdefval">lambda&#160;entry:&#160;entry.name</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Scan a directory recursively, in breadth-first order.

The returned entries are sorted according to the given key.
The default is to sort by name.
</pre> 
</div>
</div>
<a id="a500b7dde594bf79fd876fcb912114d9f" name="a500b7dde594bf79fd876fcb912114d9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a500b7dde594bf79fd876fcb912114d9f">&#9670;&#160;</a></span>spec_matches_module_path()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> bool _pytest.pathlib.spec_matches_module_path </td>
          <td>(</td>
          <td class="paramtype">ModuleSpec | None</td>          <td class="paramname"><span class="paramname"><em>module_spec</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Path</td>          <td class="paramname"><span class="paramname"><em>module_path</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return true if the given ModuleSpec can be used to import the given module path.</pre> 
<p class="reference">Referenced by <a class="el" href="#af158cc6a637b627de5fb10dc6d56dd53">_pytest.pathlib._import_module_using_spec()</a>, and <a class="el" href="#af40ce40c87f5e694865f40cbfa267f3c">_pytest.pathlib.is_importable()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace__pytest_1_1pathlib_a500b7dde594bf79fd876fcb912114d9f_icgraph.png" border="0" usemap="#anamespace__pytest_1_1pathlib_a500b7dde594bf79fd876fcb912114d9f_icgraph" alt=""/></div>
</div>

</div>
</div>
<a id="a96f2306195bc2afab763d5bd8c20ae9d" name="a96f2306195bc2afab763d5bd8c20ae9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96f2306195bc2afab763d5bd8c20ae9d">&#9670;&#160;</a></span>symlink_or_skip()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None _pytest.pathlib.symlink_or_skip </td>
          <td>(</td>
          <td class="paramtype">os.PathLike[str] | str</td>          <td class="paramname"><span class="paramname"><em>src</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">os.PathLike[str] | str</td>          <td class="paramname"><span class="paramname"><em>dst</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**Any</td>          <td class="paramname"><span class="paramname"><em>kwargs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Make a symlink, or skip the test in case symlinks are not supported.</pre> 
</div>
</div>
<a id="a94a716332cee4b0ffe6806ccfd56c390" name="a94a716332cee4b0ffe6806ccfd56c390"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94a716332cee4b0ffe6806ccfd56c390">&#9670;&#160;</a></span>try_cleanup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None _pytest.pathlib.try_cleanup </td>
          <td>(</td>
          <td class="paramtype">Path</td>          <td class="paramname"><span class="paramname"><em>path</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>consider_lock_dead_if_created_before</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Try to cleanup a folder if we can ensure it's deletable.</pre> 
<p class="reference">References <a class="el" href="#a1c3f573b2bcd340dc200f85899715bfa">_pytest.pathlib.ensure_deletable()</a>, and <a class="el" href="#a13e58fca02f174fa9bd72475840e51cc">_pytest.pathlib.maybe_delete_a_numbered_dir()</a>.</p>

<p class="reference">Referenced by <a class="el" href="#a9d1e52490b7f908dbc8b6041d0bba697">_pytest.pathlib.cleanup_numbered_dir()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace__pytest_1_1pathlib_a94a716332cee4b0ffe6806ccfd56c390_cgraph.png" border="0" usemap="#anamespace__pytest_1_1pathlib_a94a716332cee4b0ffe6806ccfd56c390_cgraph" alt=""/></div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace__pytest_1_1pathlib_a94a716332cee4b0ffe6806ccfd56c390_icgraph.png" border="0" usemap="#anamespace__pytest_1_1pathlib_a94a716332cee4b0ffe6806ccfd56c390_icgraph" alt=""/></div>
</div>

</div>
</div>
<a id="a93c510d7d87a1bd007c78df762338f1e" name="a93c510d7d87a1bd007c78df762338f1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93c510d7d87a1bd007c78df762338f1e">&#9670;&#160;</a></span>visit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Iterator[os.DirEntry[str]] _pytest.pathlib.visit </td>
          <td>(</td>
          <td class="paramtype">str | os.PathLike[str]</td>          <td class="paramname"><span class="paramname"><em>path</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Callable[[os.DirEntry[str]], bool]
</td>          <td class="paramname"><span class="paramname"><em>recurse</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Walk a directory recursively, in breadth-first order.

The `recurse` predicate determines whether a directory is recursed.

Entries at each directory level are sorted.
</pre> 
<p class="reference">References <a class="el" href="#a93c510d7d87a1bd007c78df762338f1e">_pytest.pathlib.visit()</a>.</p>

<p class="reference">Referenced by <a class="el" href="#a93c510d7d87a1bd007c78df762338f1e">_pytest.pathlib.visit()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace__pytest_1_1pathlib_a93c510d7d87a1bd007c78df762338f1e_cgraph.png" border="0" usemap="#anamespace__pytest_1_1pathlib_a93c510d7d87a1bd007c78df762338f1e_cgraph" alt=""/></div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace__pytest_1_1pathlib_a93c510d7d87a1bd007c78df762338f1e_icgraph.png" border="0" usemap="#anamespace__pytest_1_1pathlib_a93c510d7d87a1bd007c78df762338f1e_icgraph" alt=""/></div>
</div>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a0eaa54319ebbb1846a29cd4ad31da4d4" name="a0eaa54319ebbb1846a29cd4ad31da4d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0eaa54319ebbb1846a29cd4ad31da4d4">&#9670;&#160;</a></span>_AnyPurePath</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">_pytest.pathlib._AnyPurePath = TypeVar(&quot;_AnyPurePath&quot;, bound=PurePath)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4098dd7db7f37942e4d1e4898051a34d" name="a4098dd7db7f37942e4d1e4898051a34d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4098dd7db7f37942e4d1e4898051a34d">&#9670;&#160;</a></span>_IGNORED_ERRORS</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">tuple _pytest.pathlib._IGNORED_ERRORS = (ENOENT, ENOTDIR, EBADF, ELOOP)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a82dcc98dfd4f9e8e52ff548aaf17b6e8" name="a82dcc98dfd4f9e8e52ff548aaf17b6e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82dcc98dfd4f9e8e52ff548aaf17b6e8">&#9670;&#160;</a></span>_IGNORED_WINERRORS</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">tuple _pytest.pathlib._IGNORED_WINERRORS</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"><span class="lineno">    1</span>=  (</div>
<div class="line"><span class="lineno">    2</span>    21,  <span class="comment"># ERROR_NOT_READY - drive exists but is not accessible</span></div>
<div class="line"><span class="lineno">    3</span>    1921,  <span class="comment"># ERROR_CANT_RESOLVE_FILENAME - fix for broken symlink pointing to itself</span></div>
<div class="line"><span class="lineno">    4</span>)</div>
</div><!-- fragment -->
</div>
</div>
<a id="a6c097e7a2732274f1e66f46e679d3fe2" name="a6c097e7a2732274f1e66f46e679d3fe2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c097e7a2732274f1e66f46e679d3fe2">&#9670;&#160;</a></span>LOCK_TIMEOUT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int _pytest.pathlib.LOCK_TIMEOUT = 60 * 60 * 24 * 3</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace__pytest.html">_pytest</a></li><li class="navelem"><a class="el" href="namespace__pytest_1_1pathlib.html">pathlib</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.11.0 </li>
  </ul>
</div>
</body>
</html>
